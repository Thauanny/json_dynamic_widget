// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'json_button_bar_builder.dart';

// **************************************************************************
// Generator: JsonWidgetLibraryBuilder
// **************************************************************************

// ignore_for_file: avoid_init_to_null
// ignore_for_file: deprecated_member_use

// ignore_for_file: prefer_const_constructors
// ignore_for_file: prefer_const_constructors_in_immutables
// ignore_for_file: prefer_final_locals
// ignore_for_file: prefer_if_null_operators
// ignore_for_file: prefer_single_quotes
// ignore_for_file: unused_local_variable

class JsonButtonBarBuilder extends _JsonButtonBarBuilder {
  const JsonButtonBarBuilder({required super.args});

  static const kType = 'button_bar';

  /// Constant that can be referenced for the builder's type.
  @override
  String get type => kType;

  /// Static function that is capable of decoding the widget from a dynamic JSON
  /// or YAML set of values.
  static JsonButtonBarBuilder fromDynamic(
    dynamic map, {
    JsonWidgetRegistry? registry,
  }) =>
      JsonButtonBarBuilder(
        args: map,
      );

  @override
  JsonButtonBarBuilderModel createModel({
    ChildWidgetBuilder? childBuilder,
    required JsonWidgetData data,
  }) {
    final model = JsonButtonBarBuilderModel.fromDynamic(
      args,
      registry: data.jsonWidgetRegistry,
    );

    return model;
  }

  @override
  ButtonBar buildCustom({
    ChildWidgetBuilder? childBuilder,
    required BuildContext context,
    required JsonWidgetData data,
    Key? key,
  }) {
    final model = createModel(
      childBuilder: childBuilder,
      data: data,
    );

    return ButtonBar(
      alignment: model.alignment,
      buttonAlignedDropdown: model.buttonAlignedDropdown,
      buttonHeight: model.buttonHeight,
      buttonMinWidth: model.buttonMinWidth,
      buttonPadding: model.buttonPadding,
      buttonTextTheme: model.buttonTextTheme,
      key: key,
      layoutBehavior: model.layoutBehavior,
      mainAxisSize: model.mainAxisSize,
      overflowButtonSpacing: model.overflowButtonSpacing,
      overflowDirection: model.overflowDirection,
      children: [
        for (var d in model.children)
          d.build(
            childBuilder: childBuilder,
            context: context,
          ),
      ],
    );
  }
}

class JsonButtonBar extends JsonWidgetData {
  JsonButtonBar({
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
    this.alignment,
    this.buttonAlignedDropdown,
    this.buttonHeight,
    this.buttonMinWidth,
    this.buttonPadding,
    this.buttonTextTheme,
    this.layoutBehavior,
    this.mainAxisSize,
    this.overflowButtonSpacing,
    this.overflowDirection,
    this.children = const <JsonWidgetData>[],
  }) : super(
          jsonWidgetArgs: JsonButtonBarBuilderModel.fromDynamic(
            {
              'alignment': alignment,
              'buttonAlignedDropdown': buttonAlignedDropdown,
              'buttonHeight': buttonHeight,
              'buttonMinWidth': buttonMinWidth,
              'buttonPadding': buttonPadding,
              'buttonTextTheme': buttonTextTheme,
              'layoutBehavior': layoutBehavior,
              'mainAxisSize': mainAxisSize,
              'overflowButtonSpacing': overflowButtonSpacing,
              'overflowDirection': overflowDirection,
              'children': children,
              ...args,
            },
            args: args,
            registry: registry,
          ),
          jsonWidgetBuilder: () => JsonButtonBarBuilder(
            args: JsonButtonBarBuilderModel.fromDynamic(
              {
                'alignment': alignment,
                'buttonAlignedDropdown': buttonAlignedDropdown,
                'buttonHeight': buttonHeight,
                'buttonMinWidth': buttonMinWidth,
                'buttonPadding': buttonPadding,
                'buttonTextTheme': buttonTextTheme,
                'layoutBehavior': layoutBehavior,
                'mainAxisSize': mainAxisSize,
                'overflowButtonSpacing': overflowButtonSpacing,
                'overflowDirection': overflowDirection,
                'children': children,
                ...args,
              },
              args: args,
              registry: registry,
            ),
          ),
          jsonWidgetType: JsonButtonBarBuilder.kType,
        );

  /* AUTOGENERATED FROM [ButtonBar.alignment]*/
  /// How the children should be placed along the horizontal axis.
  ///
  /// If null then it will use [ButtonBarThemeData.alignment]. If that is null,
  /// it will default to [MainAxisAlignment.end].
  final MainAxisAlignment? alignment;

  /* AUTOGENERATED FROM [ButtonBar.buttonAlignedDropdown]*/
  /// Overrides the surrounding [ButtonThemeData.alignedDropdown] to define whether
  /// a [DropdownButton] menu's width will match the button's width.
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.buttonAlignedDropdown].
  /// If that is null, it will default to false.
  final bool? buttonAlignedDropdown;

  /* AUTOGENERATED FROM [ButtonBar.buttonHeight]*/
  /// Overrides the surrounding [ButtonThemeData.height] to define a button's
  /// minimum height.
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.buttonHeight].
  /// If that is null, it will default to 36.0 logical pixels.
  final double? buttonHeight;

  /* AUTOGENERATED FROM [ButtonBar.buttonMinWidth]*/
  /// Overrides the surrounding [ButtonThemeData.minWidth] to define a button's
  /// minimum width.
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.buttonMinWidth].
  /// If that is null, it will default to 64.0 logical pixels.
  final double? buttonMinWidth;

  /* AUTOGENERATED FROM [ButtonBar.buttonPadding]*/
  /// Overrides the surrounding [ButtonThemeData.padding] to define the padding
  /// for a button's child (typically the button's label).
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.buttonPadding].
  /// If that is null, it will default to 8.0 logical pixels on the left
  /// and right.
  final EdgeInsetsGeometry? buttonPadding;

  /* AUTOGENERATED FROM [ButtonBar.buttonTextTheme]*/
  /// Overrides the surrounding [ButtonBarThemeData.buttonTextTheme] to define a
  /// button's base colors, size, internal padding and shape.
  ///
  /// If null then it will use the surrounding
  /// [ButtonBarThemeData.buttonTextTheme]. If that is null, it will default to
  /// [ButtonTextTheme.primary].
  final ButtonTextTheme? buttonTextTheme;

  /* AUTOGENERATED FROM [ButtonBar.layoutBehavior]*/
  /// Defines whether a [ButtonBar] should size itself with a minimum size
  /// constraint or with padding.
  ///
  /// Overrides the surrounding [ButtonThemeData.layoutBehavior].
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.layoutBehavior].
  /// If that is null, it will default [ButtonBarLayoutBehavior.padded].
  final ButtonBarLayoutBehavior? layoutBehavior;

  /* AUTOGENERATED FROM [ButtonBar.mainAxisSize]*/
  /// How much horizontal space is available. See [Row.mainAxisSize].
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.mainAxisSize].
  /// If that is null, it will default to [MainAxisSize.max].
  final MainAxisSize? mainAxisSize;

  /* AUTOGENERATED FROM [ButtonBar.overflowButtonSpacing]*/
  /// The spacing between buttons when the button bar overflows.
  ///
  /// If the [children] do not fit into a single row, they are arranged into a
  /// column. This parameter provides additional vertical space in between
  /// buttons when it does overflow.
  ///
  /// The button spacing may appear to be more than the value provided. This is
  /// because most buttons adhere to the [MaterialTapTargetSize] of 48px. So,
  /// even though a button might visually be 36px in height, it might still take
  /// up to 48px vertically.
  ///
  /// If null then no spacing will be added in between buttons in
  /// an overflow state.
  final double? overflowButtonSpacing;

  /* AUTOGENERATED FROM [ButtonBar.overflowDirection]*/
  /// Defines the vertical direction of a [ButtonBar]'s children if it
  /// overflows.
  ///
  /// If [children] do not fit into a single row, then they
  /// are arranged in a column. The first action is at the top of the
  /// column if this property is set to [VerticalDirection.down], since it
  /// "starts" at the top and "ends" at the bottom. On the other hand,
  /// the first action will be at the bottom of the column if this
  /// property is set to [VerticalDirection.up], since it "starts" at the
  /// bottom and "ends" at the top.
  ///
  /// If null then it will use the surrounding
  /// [ButtonBarThemeData.overflowDirection]. If that is null, it will
  /// default to [VerticalDirection.down].
  final VerticalDirection? overflowDirection;

  /* AUTOGENERATED FROM [ButtonBar.children]*/
  /// The buttons to arrange horizontally.
  ///
  /// Typically [ElevatedButton] or [TextButton] widgets.
  final List<JsonWidgetData> children;
}

/* AUTOGENERATED FROM [ButtonBar]*/
/// Creates a button bar.
///
/// Both [buttonMinWidth] and [buttonHeight] must be non-negative if they
/// are not null.
class JsonButtonBarBuilderModel extends JsonWidgetBuilderModel {
  const JsonButtonBarBuilderModel(
    super.args, {
    this.alignment,
    this.buttonAlignedDropdown,
    this.buttonHeight,
    this.buttonMinWidth,
    this.buttonPadding,
    this.buttonTextTheme,
    this.layoutBehavior,
    this.mainAxisSize,
    this.overflowButtonSpacing,
    this.overflowDirection,
    this.children = const <JsonWidgetData>[],
  });

  /* AUTOGENERATED FROM [ButtonBar.alignment]*/
  /// How the children should be placed along the horizontal axis.
  ///
  /// If null then it will use [ButtonBarThemeData.alignment]. If that is null,
  /// it will default to [MainAxisAlignment.end].
  final MainAxisAlignment? alignment;

  /* AUTOGENERATED FROM [ButtonBar.buttonAlignedDropdown]*/
  /// Overrides the surrounding [ButtonThemeData.alignedDropdown] to define whether
  /// a [DropdownButton] menu's width will match the button's width.
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.buttonAlignedDropdown].
  /// If that is null, it will default to false.
  final bool? buttonAlignedDropdown;

  /* AUTOGENERATED FROM [ButtonBar.buttonHeight]*/
  /// Overrides the surrounding [ButtonThemeData.height] to define a button's
  /// minimum height.
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.buttonHeight].
  /// If that is null, it will default to 36.0 logical pixels.
  final double? buttonHeight;

  /* AUTOGENERATED FROM [ButtonBar.buttonMinWidth]*/
  /// Overrides the surrounding [ButtonThemeData.minWidth] to define a button's
  /// minimum width.
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.buttonMinWidth].
  /// If that is null, it will default to 64.0 logical pixels.
  final double? buttonMinWidth;

  /* AUTOGENERATED FROM [ButtonBar.buttonPadding]*/
  /// Overrides the surrounding [ButtonThemeData.padding] to define the padding
  /// for a button's child (typically the button's label).
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.buttonPadding].
  /// If that is null, it will default to 8.0 logical pixels on the left
  /// and right.
  final EdgeInsetsGeometry? buttonPadding;

  /* AUTOGENERATED FROM [ButtonBar.buttonTextTheme]*/
  /// Overrides the surrounding [ButtonBarThemeData.buttonTextTheme] to define a
  /// button's base colors, size, internal padding and shape.
  ///
  /// If null then it will use the surrounding
  /// [ButtonBarThemeData.buttonTextTheme]. If that is null, it will default to
  /// [ButtonTextTheme.primary].
  final ButtonTextTheme? buttonTextTheme;

  /* AUTOGENERATED FROM [ButtonBar.layoutBehavior]*/
  /// Defines whether a [ButtonBar] should size itself with a minimum size
  /// constraint or with padding.
  ///
  /// Overrides the surrounding [ButtonThemeData.layoutBehavior].
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.layoutBehavior].
  /// If that is null, it will default [ButtonBarLayoutBehavior.padded].
  final ButtonBarLayoutBehavior? layoutBehavior;

  /* AUTOGENERATED FROM [ButtonBar.mainAxisSize]*/
  /// How much horizontal space is available. See [Row.mainAxisSize].
  ///
  /// If null then it will use the surrounding [ButtonBarThemeData.mainAxisSize].
  /// If that is null, it will default to [MainAxisSize.max].
  final MainAxisSize? mainAxisSize;

  /* AUTOGENERATED FROM [ButtonBar.overflowButtonSpacing]*/
  /// The spacing between buttons when the button bar overflows.
  ///
  /// If the [children] do not fit into a single row, they are arranged into a
  /// column. This parameter provides additional vertical space in between
  /// buttons when it does overflow.
  ///
  /// The button spacing may appear to be more than the value provided. This is
  /// because most buttons adhere to the [MaterialTapTargetSize] of 48px. So,
  /// even though a button might visually be 36px in height, it might still take
  /// up to 48px vertically.
  ///
  /// If null then no spacing will be added in between buttons in
  /// an overflow state.
  final double? overflowButtonSpacing;

  /* AUTOGENERATED FROM [ButtonBar.overflowDirection]*/
  /// Defines the vertical direction of a [ButtonBar]'s children if it
  /// overflows.
  ///
  /// If [children] do not fit into a single row, then they
  /// are arranged in a column. The first action is at the top of the
  /// column if this property is set to [VerticalDirection.down], since it
  /// "starts" at the top and "ends" at the bottom. On the other hand,
  /// the first action will be at the bottom of the column if this
  /// property is set to [VerticalDirection.up], since it "starts" at the
  /// bottom and "ends" at the top.
  ///
  /// If null then it will use the surrounding
  /// [ButtonBarThemeData.overflowDirection]. If that is null, it will
  /// default to [VerticalDirection.down].
  final VerticalDirection? overflowDirection;

  /* AUTOGENERATED FROM [ButtonBar.children]*/
  /// The buttons to arrange horizontally.
  ///
  /// Typically [ElevatedButton] or [TextButton] widgets.
  final List<JsonWidgetData> children;

  static JsonButtonBarBuilderModel fromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    final result = maybeFromDynamic(
      map,
      args: args,
      registry: registry,
    );

    if (result == null) {
      throw Exception(
        '[JsonButtonBarBuilder]: requested to parse from dynamic, but the input is null.',
      );
    }

    return result;
  }

  static JsonButtonBarBuilderModel? maybeFromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    JsonButtonBarBuilderModel? result;

    if (map != null) {
      if (map is String) {
        map = yaon.parse(
          map,
          normalize: true,
        );
      }

      if (map is JsonButtonBarBuilderModel) {
        result = map;
      } else {
        registry ??= JsonWidgetRegistry.instance;
        map = registry.processArgs(map, <String>{}).value;
        result = JsonButtonBarBuilderModel(
          args,
          alignment: () {
            dynamic parsed = ThemeDecoder.decodeMainAxisAlignment(
              map['alignment'],
              validate: false,
            );

            return parsed;
          }(),
          buttonAlignedDropdown: JsonClass.maybeParseBool(
            map['buttonAlignedDropdown'],
          ),
          buttonHeight: () {
            dynamic parsed = JsonClass.maybeParseDouble(map['buttonHeight']);

            return parsed;
          }(),
          buttonMinWidth: () {
            dynamic parsed = JsonClass.maybeParseDouble(map['buttonMinWidth']);

            return parsed;
          }(),
          buttonPadding: () {
            dynamic parsed = ThemeDecoder.decodeEdgeInsetsGeometry(
              map['buttonPadding'],
              validate: false,
            );

            return parsed;
          }(),
          buttonTextTheme: () {
            dynamic parsed = ThemeDecoder.decodeButtonTextTheme(
              map['buttonTextTheme'],
              validate: false,
            );

            return parsed;
          }(),
          layoutBehavior: () {
            dynamic parsed = ThemeDecoder.decodeButtonBarLayoutBehavior(
              map['layoutBehavior'],
              validate: false,
            );

            return parsed;
          }(),
          mainAxisSize: () {
            dynamic parsed = ThemeDecoder.decodeMainAxisSize(
              map['mainAxisSize'],
              validate: false,
            );

            return parsed;
          }(),
          overflowButtonSpacing: () {
            dynamic parsed =
                JsonClass.maybeParseDouble(map['overflowButtonSpacing']);

            return parsed;
          }(),
          overflowDirection: () {
            dynamic parsed = ThemeDecoder.decodeVerticalDirection(
              map['overflowDirection'],
              validate: false,
            );

            return parsed;
          }(),
          children: () {
            dynamic parsed = JsonWidgetData.maybeFromDynamicList(
              map['children'],
              registry: registry,
            );
            parsed ??= const <JsonWidgetData>[];

            return parsed;
          }(),
        );
      }
    }

    return result;
  }

  @override
  Map<String, dynamic> toJson() {
    return JsonClass.removeNull({
      'alignment': ThemeEncoder.encodeMainAxisAlignment(
        alignment,
      ),
      'buttonAlignedDropdown': buttonAlignedDropdown,
      'buttonHeight': buttonHeight,
      'buttonMinWidth': buttonMinWidth,
      'buttonPadding': ThemeEncoder.encodeEdgeInsetsGeometry(
        buttonPadding,
      ),
      'buttonTextTheme': ThemeEncoder.encodeButtonTextTheme(
        buttonTextTheme,
      ),
      'layoutBehavior': ThemeEncoder.encodeButtonBarLayoutBehavior(
        layoutBehavior,
      ),
      'mainAxisSize': ThemeEncoder.encodeMainAxisSize(
        mainAxisSize,
      ),
      'overflowButtonSpacing': overflowButtonSpacing,
      'overflowDirection': ThemeEncoder.encodeVerticalDirection(
        overflowDirection,
      ),
      'children': const <JsonWidgetData>[] == children
          ? null
          : JsonClass.toJsonList(children),
      ...args,
    });
  }
}

class ButtonBarSchema {
  static const id =
      'https://peiffer-innovations.github.io/flutter_json_schemas/schemas/json_dynamic_widget/button_bar.json';

  static final schema = <String, Object>{
    r'$schema': 'http://json-schema.org/draft-07/schema#',
    r'$id': id,
    'title': 'ButtonBar',
    'type': 'object',
    'additionalProperties': false,
    'properties': {
      'alignment': SchemaHelper.objectSchema(MainAxisAlignmentSchema.id),
      'buttonAlignedDropdown': SchemaHelper.boolSchema,
      'buttonHeight': SchemaHelper.numberSchema,
      'buttonMinWidth': SchemaHelper.numberSchema,
      'buttonPadding': SchemaHelper.objectSchema(EdgeInsetsGeometrySchema.id),
      'buttonTextTheme': SchemaHelper.objectSchema(ButtonTextThemeSchema.id),
      'layoutBehavior':
          SchemaHelper.objectSchema(ButtonBarLayoutBehaviorSchema.id),
      'mainAxisSize': SchemaHelper.objectSchema(MainAxisSizeSchema.id),
      'overflowButtonSpacing': SchemaHelper.numberSchema,
      'overflowDirection':
          SchemaHelper.objectSchema(VerticalDirectionSchema.id),
      'children': SchemaHelper.arraySchema(JsonWidgetDataSchema.id),
    },
  };
}
